## Вопросы
### Как запустить редис из контейнера?

Запустить `cli` (1)
```bash
docker run -d redis
docker exec -it [container_id] redis-cli
```

Запустить как сервис (2)
```
docker run -p 6379:6379 redis
```
### Чем отличаются `redis-server` и `redis-cli`? Какой из редисов используется, когда я выполняю команды (1) и (2)?

Redis-server - это сам редис, субд.  
Redis-cli - это консольный клиент для взаимодействия с редисом. 
С редисом надо общаться по специальному протоколу, а redis-cli - это простейшая прога, которая это умеет. Самое то, чтобы потыкать [[1](https://redis.io/docs/getting-started/#exploring-redis-with-the-cli)].

Список других клиентов [тут](https://redis.io/docs/clients/).

Когда выполняется команда (1), мы запускаем redis-server в фоновом режиме и запускаем cli-клиент.  
Командой (2) мы запускаем redis-server (не в фоне) и выставляем наружу порт для внешней программы (которую я собираюсь писать).
## Доступные команды
[Документация](https://redis.io/commands/)

## Типы данных
Че там есть и какие у них особенности
- plain значения (просто ключ)
- хешмап
- сет и тд

[Документация](https://redis.io/docs/data-types/)

### Строки [[2]](https://redis.io/docs/data-types/strings/)
Строки - базовый тип в редисе 
- SET - GET  
- MGET - MSET - получить/установить несколько   
- SETNX, MSETNX - SET if Not eXists. Повторное использование не перезапишет существующее значение. Но не создает иммутабельные ключи, с помощью set и др команд можно перезаписать  
- GETSET, GETDEL - получить и заменить/удалить   
- DECR - INCR, INCRBY - DECRBY, INCRBYFLOAT (для чисел)  
- APPEND - SETRANGE  - добавить/перезаписать. **Внимание**: SETRANGE не может обрезать строку. Только заменить ее часть
- GETEX - SETEX, PSETEX  - установить и expire time, и значение одной командой
- LCS - найти пересечение строк

### Списки (Lists) [[3]](https://redis.io/docs/data-types/lists/)
Списки - это связанные списки (не массивы). Подходят для реализации стеков и очередей.
- LPUSH - RPUSH - добавить в список слева (head) или вправо (tail)
- LPOP - RPOP -  pop слева (head) или справа (right)
- LLEN - длина списка
- LSET - установить значение по индексу
- LPOS - получить индекс элемента списка
- LINSERT - вставить в список до/после элемента

Сложность LINSERT, LSET, LINDEX - O(n) (_что ожидаемо_). Не злоупотребляйте.

### Множества (Sets) [[4]](https://redis.io/docs/data-types/sets/)
Множества неупорядочены и хранят уникальные значения. Неупорядоченность значит, что по индексу невозможно получить элемент. Зато есть операции для нахождения пересечений, исключений, объединений.  
Элементы множества называются _members_.
- SADD - SREM - получить/удалить
- SCARD - получить размер множества (cardinality - количество элементов)
- SMEMBERS - получить все значения множества 
- SRANDMEMBER - получить n рандомных элементов
- SPOP - pop (получить и удалить) n рандомных элементов

### Сортированные множества (Sorted sets)
Так же, как и set, только с score - параметр, по которому элементы можно отсортировать
Команды
- ZADD
- ZINCRBY
- ZCARD - получить размер множества
- ZCOUNT - количество элементов в диапазоне score
- ZRANDMEMBERS - взять рандомных n элементов
- ZRANGE - базовая команда из группы команд для получения ограниченной выборки множества [[5]](https://redis.io/commands/zrange/). Общая структура названия этих команд выглядит так:  
  ```
    Z[REV]RANGE[BYLEX|BYSCOPE]
  ```
    где REV - __реверсивный__, сортировка по убыванию, BYLEX-BYSCOPE - сортировка по scope или в лексикографическом порядке (там очень странный синтаксис, не поняла how to use и usecases)

## Библиотеки
- [predis](https://github.com/predis/predis/wiki/Quick-tour#connection)

## Сложности
Как реализовать в php pub-sub? В реалтайме sub не работает... Я пока не вижу, как это можно делать

## Реализация
Очередь ожидающих (list)
Множество присутствующих на сайте (set) ограниченного размера
Набор ключей с expiration для каждой сессии

Алгоритм:
1. проверить, есть ли id сессии
2. если нет, генерировать guid для идентификации пользователя
3. если есть, то проверить, есть ли такой ключ
4. если ключ есть, он не expired, возможны два варианта: пользователь в очереди или пользователь уже на сайте

При истечении срока ключа необходимо выкинуть его из очереди допущенных на сайт. Как это можно сделать, не прибегая к брутфорсу (перебору всех ключей)?

При каком событии необходимо пускать пользователя на сайт? При повторном запросе страницы

На какой критерий опираться при решении - пускать пользователя на сайт или ставить в очередь?

При каком событии обновлять очередь ожидающих на сайт? Удалять из нее неактуальных 

Как определять, что допустимое количество посетителей уже на сайте и необходимо ставить чувака в очередь?

1. ПРоверяем наличие ключа. 
2. Если он есть и не истек, чувак в очереди или уже на сайте. Проверяем, есть ли чувак в списке допущенных на сайт. Проверяем, что в последний раз он приходил сюда не позже чем 15 мин назад
3. Если чувака нет на сайте
3. Иначе генерим новую сессию с expire=5 мин и добавляем ее в очередь 

Действия:
- пропустить допущенного чувака на сайт (если не expired и есть в set)
- поставить чувака в очередь (если ключа нет или expired)
- переместить следующего чувака (любого, уже не важен текущий пользователь) из очереди на сайт, если освободились места (самый сложный кейс, об него все ломается)

Фоново:
- обновление очереди (удалить из очереди тех, кто expired)

Фоново в очередь допущенных не перемещать. Только по запросу. Иначе есть вероятность, что мы пустим того, кому уже не надо

